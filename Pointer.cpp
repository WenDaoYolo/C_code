#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>																
int main() {
	/*
	内存Memory
	：所有程序都要在内存中运行
	内存空间就和现实空间一样，被划分为若干内存单元来使用，每个内存单元的大小为<一个字节>，并且有自己的地址
	然后通过地址来访问这些内存单元中存储中的数据，(比如现实中通过地址来精确的发快递)
	32位机，64位机器等是指地址线(物理)有32，64根
	一根线就有通电和不通电两种状态，分别对应0和1，即表示一个二进制位
	32根地址线就表示有32个二进制位，其可以表示2^32种组合，每种组合代表一个内存单元的地址来管理这个内存单元--->所以计组中也称x位机器可以一次性处理x个二进制位
	00000000 00000000 00000000 00000000B->00000000H	  /用户可以查看这些内存单元的地址
	00000000 00000000 00000000 00000001B->00000001H   /但由于二进制太长,所以会这些二进制地址会被转换为更精简的16进制来展示给用户
	00000000 00000000 00000000 00000010B->00000002H
	...
	2^32即可以管理2^32个内存单元，即可以管理总共2^32Byte(字节)=4,294,967,296Byte=4,194,304KB=4096MB=4GB
	所以32位机即可管理最多4GB的内存,而这些地址的范围(即0~2^32)称为机器的寻址范围,其他位数机器同理
	所以地址线越多,机器的寻址范围就越大,其管理的内存单元就越多(即内存就越大)
	不同类型的数据有不同的大小，而对于占用空间大于一字节的数据，会为其分配多个<连续地址>的内存单元,
	而这些连续内存单元的首地址会作为这个数据的地址

	

	指针Pointer
	*/
	int a = 4;//int 类型占用4个字节,内存分配为4个连续地址的内存单元 假设地址分配为0x000000D6C0CFFB64
			 //实际占用的4个内存单元地址分别为：
						/*
						0x000000D6C0CFFB64		-->一个地址8个字节，所以机器为64位
						0x000000D6C0CFFB65
						0x000000D6C0CFFB66
						0x000000D6C0CFFB67
						*/
	printf("%p\n",&a);	//由于是动态内存分配(实时变化),所以每次运行程序时都是随机分配内存单元，其对应的地址也就会不一样
						//%p,地址的输入输出格式
	//&a表示a的地址，也是一种值可以被存储
	//而存储这种地址类型值的变量被称为<指针变量>,<是一个地址>               
	//定义格式:类型* 名字=&名字            <类型>取决于存储的地址所对应值的<类型>
	/*

	*/
					//&取地址符,任何涉及到地址的操作都需要取地址操作符

	int* p = &a;	//指针变量p赋值为a的地址,也称为指针变量p指向了a	(理解:p拿到了a的地址，就可以精确的指向了a)
					//语句解读:*声明p是一个指针变量,int声明p所指向的是一个整型的数据,=&a取变量a的地址赋值给p
					
	int b = 10, c = 11;
	int *p_1 = &b;		//指针变量的定义，*位置不唯一，选择最好理解的方式即可(推荐两个声明绑在一起)
	int * p_2= &c;
						//指针变量用来存储地址类型的值，其本身也是占用内存单元的，也有地址
						// 所以不同的指针之间也是可以相互指向的,存放变量地址的指针称为<一级指针>,存放一级指针地址的指针称为<二级指针>，暂不深入研究
						//那指针是否能存放自己的地址？-->可以存放值，但会出现类型差异(自己指向自己，其指向的类型是无法确定的)
						//tip：指针指向的地址或类型不确定时，此时称为野指针		-->所以这是一个错误的写法
	int* test = p_1;	//p_1本身就是一个地址，无需再用取地址符号
						//解地址操作符*,解引用操作,通过地址找到对应的数据,格式:*地址
	
	int* test02 = &c;	//通过指针变量获得变量c的地址
	*test02 = 20;		//通过地址找到变量c，并为其赋值
	*(&c) = 30;			//拓展学习,写法正确但没有意义:取变量c的地址再通过这个地址又找到变量c(取址再解址),并为其赋值--->类似于一个数乘以2后再除以2
	printf("%d\n",c);	//直接输出变量c
	printf("%d\n",*test02);	//解引用操作,通过地址找到对应的变量c并输出
	/*
	指针变量的大小:
	指针变量存储的是地址，所以其大小取决于地址的大小，而地址的大小则取决于机器的位数
	例如：32位机器，其地址线为32，所以指针变量的大小也为32位(即4个字节)
	*/
	printf("%d\n",sizeof(int*));
	printf("%d\n", sizeof(char*));
	printf("%d\n", sizeof(short int*));
	printf("%d\n", sizeof(long int*));
	printf("%d\n", sizeof(long long*));
	printf("%d\n", sizeof(float*));
	printf("%d\n", sizeof(double*));





	return 0;
}
