#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
/*
	操作符复习1
*/

int JudgmentNum(int a) {
	int count = 0;
	while (a) {
		if (a % 2 == 1)			//取余判断是否为1
			count++;			
		a /= 2;
	}
	return count;
}
/*
	但以上方法不使用于求负数
	例如-1:其补码11111111 11111111 11111111 11111111	求出结果为0
	因为-1%2余-1，-1/2商0，0为假则循环结束
*/
//改进:
//将函数参数改为无符号整型		->以无符号整型的方式接收参数,此时-1(实际是补码的形式存储和传递)其补码最高位就会被判断为数据位
//即11111111 11111111 11111111 11111111对其进行模运算和除运算
int JudgmentNum2(unsigned int a) {
	int count = 0;
	while (a) {
		if (a % 2 == 1)			//取余判断是否为1
			count++;
		a /= 2;
	}
	return count;
}
//改进2:使用按位与和右移方式			//注意此编译器右移采用的是逻辑右移,则高位会补符号位,所以不能用真假去判断(负数则高位一直补1,永远不会为0)
int JudgmentNum3(int a) {
	int count = 0;
	for (int i = 1; i <= 32; i++) {		//32位二进制,则右移31次就全部判断完了(数据原始的低位本身就已对齐无需再移位),但循环需要走32趟-->因为是判断完再右移,右移后还要进行判断
										//即:每一次判断,都是判断的上一次的移位,所以31次移位则需要32次判断	(第32次判断判断第31次的移位,所以循环仍需要走32趟)
										//也可以让i从0开始,移位放判断前或判断中(先位移),这样就可以实现移位和判断的同步	第一次移位0(本身不需要移位)从第二次开始再移位判断,-->实际上是0到31还是32次循环
		if ((a & 1) == 1)				
			count++;
		a >>= i;						//i=31时,向右移31位进行最后一位的对齐,在i=32时完成这一位的判断
	}
		
	return count;
}

//-1:11111111	11111111  11111111  11111111
//&1:00000000   00000000  00000000  00000001
//若得出1:								   1
//则当前低位为1,然后右移丢弃当前已经判断完的低位


//改进3:
//使用a=a&(a-1)					 <算法思想> :原来是1，-1则变为了0，原来是0,-1则高位借1变为1	,所以-1部分与原来的位置进行与运算始终可以置0
/*						  count		        :所以再与原来的数进行与运算,其他位都保持不变,只有-1的部分和之前置0的部分进行与运算一定可以置0
	1111	n				1			
	1110	n-1
	1110	n				2		
	1101	n-1
	1100	n				3
	1011	n-1
	1000	n				4
	0111	n-1
	0000	n				5
							每次与完都将右边的1给置0了,已经判断过的位置不管是1还是不是1都全部置0,没判断的部分则保持不变,所以与了几次就代表有几个1
*/

int JudgmentNum4(int a) {
	int count = 0;
	while (a) {
		a = a & (a - 1);
		count++;
	}
	return count;
}

//判断2的n次方
int JugmentTwo(int num) {
	int flag = 1;
	if (num == 0)
		return 0;
	while (num != 1) {
		if (num % 2 != 0) {
			flag = 0;
			break;
		}
		num /= 2;
	}
	return flag;
}


//算法思维改进:一个数若是2的n次方,则这个数的二进制只有1个1
//		10000		=2^4
//-1	01111
// 10000&01111=0
//所以只需要判断n&(n-1)是否为0即可判断	--->只有一个1,-1后则相当于所有位取反,再与原数进行与运算则一定是0
int JugmentTwo2(int num) {
	if ((num & (num - 1)) == 0)
		return 1;
	else
		return 0;
}


int main() {
	int a = 5, b, c;
	c = ++a;							//c=6 a=6
	b = ++c, c++, ++a, a++;				//c=8 b=7 a=8
	b += a++ + c;						//+优先级高于+=,b=23，a=9
										//a++的优先级虽然高于+,但是后置++的特性则是先使用再运算
	printf("a=%d,b=%d,c=%d",a,b,c);		//9	23 8
		
	/*
		求一个数在计算机中(即补码,计算机中存储的都是补码)其二进制1的位数(32位)
		取余R的特性:模运算得出的结果一定小于R-->常见使用场景1.可以控制其数的范围2.模R则可以求R进制数中每一位上的数字
		推导:只需要判断1的个数, 所以不用在意方向
		15%10得5		
		15/10得1		去掉5
		1%10得1
		1/10得0结束		去掉1

		二进制同理
		15				对应补码:1111				---省略前面0
		15%2=1			得1
		15/2=7			得7(去掉二进制低位1)		111
		7%2=1			得1
		7/2=3			得3(去掉二进制低位1)		11
		3%2=1			得1
		3/2=1			得1(去掉二进制低位1)		1
		1%2=1			
		1/2=0			得0结束(去掉二进制低位1)	0
	*/

	int s = 15;
	int s2 = -1;
	int s3 = -1;
	int s4 = -1;
	int ret = JudgmentNum(s);
	int ret1 = JudgmentNum2(s2);
	int ret2 = JudgmentNum3(s3);
	int ret3 = JudgmentNum4(s4);
	printf("\n%d,%d,%d,%d补码的个数分别是%d-%d-%d-%d\n",s,s2,s3,s4,ret,ret1,ret2,ret3);	

	/*
	练习:判断一个数字是不是2的n次方

	*/
	int num = 0;
	int num2 = 0;
	printf("请输入两个数字n:");
	scanf("%d%d", &num,&num2);
	int ret4 = JugmentTwo(num);
	int ret5= JugmentTwo2(num2);

	if (ret4)
		printf("%d是2的n次方\n",num);
	else
		printf("%d不是2的n次方\n",num);
	if (ret5)
		printf("%d是2的n次方\n", num2);
	else
		printf("%d不是2的n次方\n", num2);

	//编程的尽头是数学
}
