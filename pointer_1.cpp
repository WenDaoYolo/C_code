#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
/*
	初阶指针

	指针是有类型的，并且其类型也是有意义的
	1.指针类型决定了指针解引用的访问权限(解引用能访问多少字节和内容)
	int型则能访问4个字节,float型则能访问8个字节,char型则能访问1个字节...
	
	int a = 0x11223344;			//一个8位十六进制数,每一位四个二进制位
	char* sp = &a;			
	*sp=0;						//char型指针,解引用只能访问到1个字节,所以赋值只能改变一个字节的内容 
	赋值后：a=0x00223344	

	较早版本的编译器支持这样的写法:即使类型不同,但因为指针大小和变量地址大小相同,所以存得下其地址,但解引用能访问内容就有限制了
	
	现编译器(vs2022)采用更严格的标准,不支持不同类型指针赋值不同类型变量\数组的地址


	2.类型决定指针的步长(指针一步能走多远,指针运算的单位权重,即操作一个指针单位实际操作了几个内存地址)
	例如:整型指针+1：指向下一个整型数据,则跳过了一个整型的数据(即4个字节的地址)
		 字符型指针+1:指向下一个字符型数据,则跳过了一个字符型的数据(即1个字节的地址)
		 单精度型指针+1:指向下一个单精度型数据,则跳过了一个单精度型的数据(即4个字节的地址)
		 ...
	->指针加减整数属于指针运算，也称为指针的偏移,偏移的大小称为偏移量
	例如p+3,p指针向后偏移了3个单位,则偏移量为3

	int *a;
	a+1;		指向下一个整型数据,则实际跳过了4个字节			
	char *b;	
	b-1;		指向前一个字符型数据,则实际跳过了1个字节
	double *c;
	c+3			指向该数据后的第三个双精度型数据,则实际跳过了3x8=24个字节


*/
int main() {
	int* p1;
	char* p2;
	float* p3;
	printf("%d\n",sizeof(p1));				//64位及其，指针大小为64位(8个字节)
	printf("%d\n", sizeof(p2));
	printf("%d\n", sizeof(p3));




	int test1[4] = { 0 };
	int* test11 = test1;
	char test2[4] = { 0 };
	char* test22 = test2;
	double test3[4] = { 0 };
	double* test33 = test3;
	printf("%p\n",test11);
	printf("%p\n", test11+1);
	putchar('\n');
	printf("%p\n", test22);
	printf("%p\n", test22 + 1);
	putchar('\n');
	printf("%p\n", test33);
	printf("%p\n", test33 + 1);

	return 0;
}
