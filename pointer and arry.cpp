#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
/*
	
	操作符优先级	例如*--p	->指针p先--再解引用

	 指针+指针		->没有意义

	 c语言的例外标准:数组越界地址的比较
	允许用数组最后一个元素后面的那个地址参与比较，但不允许用数组第一个元素前面的那个地址参与比较
	尽量还是避免这么写，因为有的编译器是不支持这种标准的




	数组和指针

	数组名->首元素的地址	
	 所以指针指向了数组后同样也能用下标法	p[2]<-->*(p+2)	 指针的灵活多变

////////////////////////////////////////////////////////////////////////////////////////////
	冷知识:数组元素的表示有一种独特的写法:arr[2]<==>2[arr]
	根据交换律的规则推导而来，语法也是支持这么写的
	例如a+b,+的操作数为a和b,交换律后为b+a
	arr[2],[]的操作数为arr和2,交换律后为2[arr]
	其他满足交换律的操作符也可以这样推导---->只是扩展认知这是一种对的写法,但写代码还是按照常规思维和语法去写
////////////////////////////////////////////////////////////////////////////////////////////
	
	多级指针
	指向其他(非指针)变量的指针，则称为一级指针
	而这个一级指针也是个变量，在内存中也有地址
	所以指向一级指针的指针就称为二级指针
	三级指针则是指向二级指针的指针
	...

////////////////////////////////////////////////////////////////////////////////////////////
	各级指针的格式声明和详解

	例如:
	变量:int a=10;	//定义一个变量a

	一级指针:int* pa=&a;		//*声明pa是指针变量,int表明指向的对象是整型
	同时int*也是该指针的类型(整型指针,一级)

	二级指针:int** ppa=&pa;		//后面的*声明ppa是指针变量,int*表示指向对象是一个一级的整型指针
	同时int**也是该指针的类型(整型指针,二级指针)

	三级指针:int*** pppa=&ppav  //后面的*声明pppa是指针变量,int**表示指向对象是一个二级的整型指针
	同时int***也是该指针的类型(整型指针,三级指针)

	...依次类推
	语法是支持这样写的,但生活中大多情况下最多就用到二级指针

	二级指针与一级指针的关系及其作用――>详见double pointer.png
////////////////////////////////////////////////////////////////////////////////////////////

	指针数组									

	区别:不等同于数组指针,数组指针(主语是指针)：指向数组(首元素)的指针
	
	指针数组(主语是数组):存放指针型元素的数组
	例如:
	char arr1[10]		存放字符型元素的数组			字符型数组
	int arr2[10]		存放整型元素的数组				整型数组
	int* arr3[10]		存放指针型(整型)元素的数组		整型指针数组

	指针数组也最好初始化					   暂时了解，后续深入学习

*/
int main() {
	int arr[] = { 1,2,3,4,5 };
	int* p = NULL;
	int num = sizeof(arr) / sizeof(int);
	for (p = &arr[num]; p >= &arr[0]; p--)
			*p = 0;

	int* b = arr;
	while (b < &arr[num])
		printf("%d\n",*b++);		//操作符的优先级,先解引用再p后置++
	putchar('\n');

	int test1[10] = { 0 };
	int* pt = test1;
	for (int j = 0; j < 10; j++) {
		printf("%p<==>%p\n",&test1[j],pt+j);
		*(pt + j) = j;
		printf("value[%d]=%d\n",j,*(pt+j));
	}
	putchar('\n');
	

	return 0;
}