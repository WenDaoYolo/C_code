#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
/*
		调试技巧
		
		窗口:调用堆栈	-->监视栈区中函数调用,销毁的过程和逻辑

		设置条件断点,当满足条件时才会触发断点				->断点处右击条件

		错误类型:
		运行报错	->程序执行时报错			 ->所以调试解决的都是运行错误和程序逻辑方面的问题
		编译报错	->程序编译无法通过			

*/

void test3() {		
	printf("hehe\n");
}

void test2() {
	test3();
}

void test1() {
	test2();
}

int main() {

	test1();			//调试中的调用堆栈窗口可以查看函数调用的逻辑和过程(函数调用和销毁的过程)	
	int j = 0;
	for (int i = 0; i <= 500; i++) {			
		j = i;			//假设怀疑或推理出i执行到250次时,循环体内会出问题,此时就可以设置断点条件(i=250),当满足断点条件时才会触发断点
	}


	//test1
	int i = 1;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	for (i = 0; i <= 12; i++) {
		arr[i] = 0;
		printf("hehe\n");			//会打印什么结果呢?
	}								
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//x86的架构下-->陷入死循环-->通过调试发现越界访问地址时会访问到i的地址(在一定程度上的巧合),所以此时i就被改为了0如此往复陷入死循环
	//		     -->有越界错误,但一直死循环无法直接进行报错 

	//巧合的原因:局部变量都定义在栈区中,栈区中由下而上其地址是由低到高的,而栈区的规则是先使用高地址  
	
	//不同编译器使用规则都一样,但局部变量具体的存放位置和之间的间隔不一样
	// 例如vc6.0局部变量i就和数组的地址是相邻的,即两者之间隔了0个整型
	//									       gcc两者之间隔了1个整型
	//                                    vs(2013)两者之间隔了2个整型
	//										其他编译器和版本:暂未测试
	

	// 所以先定义i再定义数组,i的地址就高于arr的地址,数组越界到<一定程度>就会访问到i,从而更改i的值陷入死循环
	// 若是先定义数组再定义i,则数组地址是高于i的地址,则数组越界访问不会访问到i，因此会直接运行报错
	

	// x64架构下不管是先定义什么都会直接运行报错
	
	//详见debug_2.png和debug_2_1.png	
	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//<区分栈区和栈！这里讲的是内存中的栈区,并不数据结构中的栈结构!他们有相似之处,但也有区别!>:一个是数据结构,是一种算法和思维;一个是内存中的实际存储空间和单元
	// 之前讲在栈区中进行函数调用先进后出的那个调用过程才是数据结构中的栈
	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	return 0;
}