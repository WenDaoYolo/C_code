#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>
#include "Add.h"					//自定义头文件引用
/*
	函数的嵌套调用和链式访问

	函数的嵌套调用
	注意函数之间都可以互相调用，但不能嵌套定义!

	注意:c语言是逐过程式,函数定义一定要在函数调用之前			即<先定义再调用>
		 要注意函数定义的位置,所以一般函数都定义在主函数之前,方便系统先识别到函数的定义，再去调用

	若不好把握函数定义的位置，谁先谁后问题，可以通过<函数声明>来解决：
	在头文件中<统一>进行函数声明,从而解决函数定义的位置问题————>因为头文件的引用是在程序执行之前就会预处理的
	从而保证声明一定在执行之前,因此函数的声明一般存放在<自定义头文件>之中————>所以还要引用对应的头文件
	自定义头文件引用格式:#include "头文件名.h"


	tip:函数声明只负责告知编译器，有这个函数，具体存在与否取决于有没有函数定义

	函数声明格式:返回值类型 函数名(参数类型1,参数类型2,....)


	函数的链式访问
	通过将一个函数的返回值作为另一个函数的参数的方式,将函数串接起来




	////////////////////////////////////////////////////////////////////////////////////
	指针的<链式访问>:				后续再深入了解!
	是指针灵活方便的体现之一
	数组的开辟需要一块连续的空间，在c中(其他语言未知)数组开辟空间后就无法再次进行修改

	通过指针链式访问的方法可以将零散的内存空间串连起来形成一个物理上不连续，但逻辑上连续的空间,
	这种存储方式称为链表,通过更改指针的指向可以随意添加或删除空间

	相比于数组不需要申请一块大的连续的空间，只需要零散的内存空间即可形成<链表>


	////////////////////////////////////////////////////////////////////////////////////
*/

void test3() {					//定义test3
	printf("hehe\n");
}

void test2() {					//定义test2，调用test3
	test3();
}

void test1() {					//定义test1，调用test2
	test2();
}

//注意顺序	test3定义后被test2调用，test2定义后被test1调用,test1定义后被主函数调用

int main() {
	void test4(int);				//函数的声明,可以放在主函数中，但不能完全保证声明一定在调用前，所以不建议在主函数中声明
	test1();						//函数的嵌套调用	主函数调用test1
	printf("%d", strlen("abc"));		//函数的链式访问——>将函数strlen函数的返回结果作为参数传给printf函数
	printf("\n");
	printf("%d", printf("%d", printf("%d", 43)));//函数的链式访问,printf()函数的返回类型是整型，返回的是这个函数在屏幕上打印字符的个数

	//所以执行过程为:外层往内层里面调用,然后从内层开始往外执行
	//内3打印43，返回2给内2，内2打印2，返回1给最外层，最外层打印1
	test4(666);
	printf("\n%d\n", Add(6, 4));

	return 0;
}


int Add(int a, int b) {								//因为已经在头文件中进行了函数的声明,所以函数定义的位置就不必去纠结了
	return a + b;
}													//但是对于良好的编程习惯，编写的函数会单独存放在另一个源文件中方便统一管理和结构划分
													//自定义库函数:
													//用一个单独源文件存储用户编写的函数，再通过头文件声明这些函数形成一个集合—>系统自带函数库的编写就是这个原理

													//由此也可以体现出<程序的模块化>和<项目的多人分工>

void test4(int a) {					//函数不一定必须定义在使用之前，但一定要保证先声明再使用
	printf("\n%d\n", a);
}
