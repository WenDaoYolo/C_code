#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
/*
	操作符详解

	[]下标引用操作符	下标法的使用	 ->指针和数组用来访问对象的一种方法
	[]的操作对象有两个	数组名和下标
	数组名[下标]

	()函数调用操作符	    不同的场景可能是不同的操作符,例如改变表达式优先级,结合律等,要区分
	function();			    ()操作符调用函数(如果有参数还得传参)
	()的操作对象有n+1个 	n是函数参数的个数,1是函数名

//////////////////////////////////////////////////////////////////////////////////////////////////////

	自定义的结构体类型		->描述更复杂对象的类型属性		
	类型声明格式:struct 结构体类名		  struct可省略

	结构体操作符	                ->专门用来访问结构体类型对象的成员

	成员访问.						访问结构体的成员,操作对象有两个:对象名(结构体类型)和访问的对象成员

	指针访问->		                操作对象有两个:结构体指针和访问的对象成员
	结构体对象就和普通变量一样，也是有地址的
	用->通过指针直接访问对象成员   无需解引用,再通过.间接访问
//////////////////////////////////////////////////////////////////////////////////////////////////////

	总结:1.结构体名.成员
		 2.结构体指针->成员		   等价于*(结构体指针).成员	   ->太麻烦

//////////////////////////////////////////////////////////////////////////////////////////////////////

	表达式的求值:由操作符的优先级和结合性决定,同时过程中可能还会出现类型转换,也会影响求值

	隐式类型转换,算术转换
	
	隐式类型转换:	->整型提升,数据截断		->cpu的工作特性,在满足条件的情况下会自动进行的转换

	cpu的特性:cpu内的运算,操作的都是整型数,所以在运算时若数据大小低于整型的大小,为了保证精确度则会先对其进行整型提升,
	再送入cpu进行处理,运算完的结果若要存储到一个低于整型大小的变量之中则会对其进行截断存储

	数据截断:把数据存储到变量中，当数据的类型大小大于变量的类型大小，则会从低位到高位进行截断再存储到变量之中
	整型提升:进行<整型操作>或<操作符运算(即运算)>时,若运算对象的<类型大小低于整型>时，则会进行整型提升->高位补数提升至整型大小
	有符号数:高位补的数取决于原数的符号位
	无符号数:高位补的数统一为0

	算术转换:又称寻常算术转换

*/
struct book {			//自定义书的类型
	char name[10];		//需要描述的属性
	char id[6];
	int price;
};

void test1() {
	printf("hehe\n");
}
void test2(int a) {
	printf("%d\n",a);
}
int main() {
	int arr[] = { 1,2,3,4 },a=10;
	printf("%d\n", arr[1]);			//通过下标访问元素
	test1();
	test2(a);
	putchar('\n');
	struct book book1 = { "cpp","12366",188 };		//创建book类型的对象book1	   或者叫对象
	printf("书名:%s\n",book1.name);					//结构体访问操作符访问book1对象的成员name
	printf("ID:%s\n", book1.id);					//结构体访问操作符访问book1对象的成员id

	book* bp = &book1;								//book1的地址赋给结构体指针变量bp
	//通过地址指针访问结构体的成员
	//间接访问
	printf("间接访问,book1的name=:%s\n",(*bp).name);//通过bp存放的地址解引用找到book1，再通过.访问成员
	//直接访问
	printf("直接访问,book1的id=:%s\n", bp->id);		//直接用->通过结构体指针访问其对象的成员
	///////////////////////////////////////////////////////////////////////////////////////////////////////

	//数据截断与整型提升

	char test1 = 3;		
	//test1是字符型大小为8位二进制,而3是一个整型数据大小为32位二进制,此时将3存储到test1中就会对3进行数据截断
	//3的补码:00000000 00000000 00000000 00000011
	//数据截断后00000011再存储到test1中

	char test2 = 127;
	//同理得:01111111

	char test3 = test1 + test2;			 //操作符运算,则会进行整型提升
	//test1和test2进行运算,先对二者进行整型提升，再运算得到结果后截断存储
	//test1:补码00000011	->00000000 00000000 00000000 00000011
	//test2:补码01111111	->00000000 00000000 00000000 01111111
	//运算:	补码00000000 00000000 00000000 10000010
	//数据截断:test3=10000010
	printf("数据截断与整型提升:%d\n",test3);		//整型操作,则会进行整型提升
	//又将test3以整型的格式输出,则又会对其进行整型提升	-> 符号位为1,则高位全补1
	//11111111 11111111 11111111 10000010	->补码	    ->补码运算和存储,原码输出打印!!!
	//10000000 00000000 00000000 01111110	->原码	    ->-126

	//test2:
	char aa = 0xb6;
	int bb = 0xb6000000;
	if (aa == 0xb6)					  //操作符运算，则会进行整型提升  

	//aa:  10110110	            			  ->对0xb6数据截断后成了负数
	//aa:  11111111 11111111 11111111 11001010->补码	->整型提升高位补符号位1
	//0xb6:00000000 00000000 00000000 10110110->补码	->本身就是正数

    //即<数据截断>和<整型提升>都改变了表达式的值

		printf("no\n");
	if (bb == 0xb6000000);			 //本身就是整型
		printf("yes\n");

		printf("%d\n",0xb6);
		printf("%d\n", aa);
	//test3:
		char k = 1;
		printf("%u\n",sizeof(k));	//%u是无符号整数,%d是有符号整数,sizeof返回的结果是无符号整数,可以以%d格式打印,但会警告
		printf("%d\n", sizeof(+k));	//进行操作符运算,则会进行整型提升,所以sizeof实际求的是一个整型数据的空间大小
		printf("%d\n", sizeof(-k)); //同理
		printf("%d\n", sizeof(!k)); //同理,也应该为4，由于vs编译器的处理不同所以为1		gcc下为4,以gcc为标准


		//sizeof实际没有执行括号内的表达式,只是对其中表达式的结果类型进行了分析(是计算机分析出来,不是去执行后得出来的),从而在编译阶段就得到了结果
		//所有表达式都有两种属性,值属性和类型属性	而sizeof只是对类型属性进行了分析,并没有去进行值属性的操作
		//例如:int a=4,b=5
		//a+b,则值属性为9，类型属性则为int

		//总结:sizeof()的工作原理是,对表达式进行类型分析获取结果而非执行表达式获取结果
		//sizeof的返回类型是无符号整型




	return 0;
}