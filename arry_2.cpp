#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
/*
 数组
 二维数组篇:多个一维数组数组组成的一个数组
 创建：												良好的编程习惯:创建即初始化

 类型 数组名[一维数组个数][每个一维数组的长度](每行有多少列)

 或者理解为:[行数][列数]		每个一维数组可以理解为1行，每个一维数组的长度可以理解为列数
			
初始化

完全初始化和不完全初始化:
一次性初始化:
char a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}			从左到右，从上到下依次赋值，元素不够自动补'\0'
分组性初始化:
int a[3][4]={{1,2},{5,6,7,8},{9}}					分隔每个一维数组，单独为每个一维数组赋值，元素不够自动补0

二维数组定义时的省略
可以省略行数，但不可以省略列数,此方法必须初始化->数组会根据<行数>或者<元素个数>、<列数>自动为数组赋值行长度

二维数组元素的访问：
下标法:数组名[行数][列数]		每一行和列的起始下标均为0
指针运算法:		*(地址+偏移单位)

为什么列数不同省略?		二维数组在内存中也是连续存储的形式,只有固定了列数的长度,才能判定出每一行的开始和结束(详见图)	
通过地址打印可以发现:每个元素地址之间的间隔是相同的				  ―>所以无论是行内还是行与行,其元素地址都是<连续>的
所以指针运算法同样适用与二维数组元素的访问

二维数组的数组名:则代表整个二维数组
二维数组中每个一维数组的数组名:数组名[一维数组的下标]			如：a[3][4],第一个一维数组的数组名就是a[0]...

*/

int main() {
	int a[][4] = { 1,2,3,4,5};				//行数为2
	char b[][4]{ {'a','b'},{'a'},{}};		//行数为3
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 4; j++)
			printf("%d ", a[i][j]);
		putchar('\n');
	}
		putchar('\n');
	for (int i = 0; i < 2; i++)
		for (int j = 0; j < 4; j++)
			printf("&a[%d][%d]=%p\n",i,j,&a[i][j]);		//打印地址
	return 0;
}