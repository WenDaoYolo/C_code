#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
/*
	函数递归:大事化小
	一种编程技巧，广泛运用于各种算法之中			  注意是思维，所以没有固定的写法
	函数直接或者间接调用函数自己
	递归思维只需要少量代码就可以描述过程中需要多次重复的计算								

	//////////////////////////////////////////////////////////////////
	<核心思维>:把一个大型的复杂的问题<层层>转换拆解为一些规模小且相同或相似的问题来进行求解		

		   先调用，调用完全结束后再回溯执行						画图更好理解
	           每次主调函数都要等相对的被调函数执行完，才能继续执行后面的代码			注意,函数结束的两种情况:1.空类型执行完代码过程	2.其他类型返回结果
	举例:
	主函数调a,等a执行完返回,主函数才能继续执行，而a又去调b，等b执行完f返回,a才能继续执行，
	而b又去调c，等c执行完返回,b才能继续执行，c执行完返回b,b继续执行，b执行完返回a,a继续执行，a执行完返回主函数,主函数继续执行
	而递归自己调自己，无非是将这些互调的函数换成同一个函数，然后通过两个必要来控制递归的结束

	两个必要:
	条件的限制:达到条件后不再调用
	变量的变化:参与条件判断的的量，在每一次<调用后>,这个量都会靠近条件限制
	和循环判断部分，变化部分的作用一样，使其不会陷入死循环		栈溢出

	栈的工作原理:
	内存中的栈区，用于存储局部变量，形参，函数等临时变量
	每创建一个局部变量，或者调用一次函数都会在这个栈区上申请一块空间来存储
	而当死递归或者递归次数过多(递过过深)的时候，栈区的内存被分配满，就会发生栈溢出(Stack OverFlow)的问题

	//stackoverflow网站，程序员的知乎

        递归的构建思路:
        找最小最简单事件
        构建限制条件和参与判断的量
        重复调用将大事件层层拆分，转变为这些小事件，达到限制后停止调用开始执行回溯
	其他思路：编程中的递归来源于数学中的递归思维，因此用能数学公式表示出问题，那么编程就很容易去实现
 
	总结:顺序调用，逆序执行，外层向内层调用，内层向外层执行			
	//////////////////////////////////////////////////////////////////



	例1：最简单的一个递归,但这是一种错误的示范
	int main(){
	printf("hehe\n");
	main();
	}
	自己反复调用自己，陷入死循环		栈溢出
	
	例2:
	1234,求出每一位上的数字(1,2,3,4)
	常规思维:
	个位=1234%10
	十位=1234%100/10
	百位=1234/100%10
	千位=1234/1000
	...				数字越大,其计算和代码就越复杂

	递归思维:
*/
void print(int num) {
	if (num > 9)						//通过if来进行递归的控制
		print(num / 10);				//没达到限制，则调用自己
	printf("%d ",num%10);				
}
//详见function_7.png
/*
	例3:
	用递归输出斐波那契的前20项
	Fib:0	1	1	2	3	5	8	13	21	34	...
	通过分析:从第三项开始,每一项都等于前两项的和,所以可以确定最简单基本的事件就是第一个元素0和第二个元素1
	这两个元素就可以用于控制递归的结束,后面的元素可以表示为F（n）=F(n-1)+F(n-2)


	递归法求斐波那契的效率是要低于常规方法的，而这里采用递归法是为了锻炼递归思维
*/

int Fib(int n) {							
	if (n == 0)			//通过计数测试，求第40个fibonacci数时，第三个fibonacci数(即2)被重复计算了3000多万次！！	所以递归很容易栈溢出，要慎重使用				
		return 0;
	else if (n == 1)
		return 1;
	else
		return Fib(n - 1) + Fib(n - 2);	
}
//详见Fib.png


int main() {
	int num = 0;
	scanf("%d",&num);
	print(num);
	putchar('\n');
	for (int i = 0; i < 20; i++)
		printf("%d ",Fib(i));

	putchar('\n');

	//斐波那契常规思维				a=0	b=1 c=a+b....
	int a = 0, b = 1, c;
	printf("%d %d ",a,b);
	for (int i = 1; i <=18; i++) {	//每次更新迭代都可以求出一个数，已知两个数剩下18个则需要进行18次更新迭代
		c = a + b;
		printf("%d ", c);
			a = b;				//初始定义a为0，b=1，每次通过a和b求出第三项c,然后再更新迭代a和b
			b = c;
	}


	

	return 0;
}
