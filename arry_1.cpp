#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
/*
数组，一组相同类型元素的集合

初始化:为数据赋初值

一维数组篇--->

数组的定义和初始化:
类型 标识符	长度(常量表达式)	—>但C99语法支持变长数组:数组长度用变量	例如gcc编译器支持C99
大部分情况下都视为只能用常数

完全初始化:数组的每一个元素都赋了初值
int arry[4]={1，2，3，4}；
不完全初始化:数组有元素没有赋初值	<未赋值的元素会自动赋值为0>
长度省略定义：省略数组的长度定义，数组则会自动根据元素个数定义长度->所以此定义法必须初始化
float arry2[]={1.1,2.2,3.6,4.4,5.4,6.11}		 则数组长度为6


字符型数组的定义及初始化
	两种定义和初始化方法
	单字符型初始化：
	char test1[5]={'a','b','c','d'}			
	字符串型初始化:
	char test2[5]="abcde"						字符串会默认在结尾添加一个隐藏的\0结束符
	char test3[5]={"abcde"}
	所以若是字符串型初始化的数组则和字符串的特性一样，实际占的空间大小为元素个数+1(\0转义字符占一个字节空间)
	占空间但不算字符串的内容
	<未赋值的元素会自动赋值为\0>

	注意：单字符型初始化可以不添加'\0',但若要以字符串形式进行相关操作时(例如字符串形式输出,字符串相关函数等)，必须要补\0结束符来进行判定
	若不以\0结束，则字符串无法判定是否结束，会一直操作随机值直到遇到\0

	数组中每个元素都有一个下标，起始下标为0，从左往右依次+1

	数组名就是数组首元素的地址，也代表整个数组的地址
	访问数组中元素的方法：
	1.下标法	数组名[元素下标]		通过下标引用操作符
	2.地址法	*(首地址+偏移单位)		指针算术:指针加减法，操作1个单位实际偏移量是1*sizeof(arry type)个字节	指针运算是指针变量的运算不是地址的运算	
										偏移量:相对于某一个地址 实际偏移了多少个内存单元(即字节或者地址)
										注意不同类型的数组，其元素大小不一样，之间的间隔有差异，所以其实际偏移量也不同
										 一个内存单元编一个地址
										例如：
									    字符型占一个内存单元(一个字节)，每个元素之间地址间隔为1	指针偏移一个单位实际偏移1个字节地址
										整数型占四个内存单元(四个字节)，每个元素之间地址间隔为4	指针偏移一个单位实际偏移4个字节地址
										其他同理...


指针与数组的名不同，但也有相似的地方

1.性质
数组名指向首元素的地址，代表整个数组，是常量，是不可修改的左值
指针是一个变量，存储的是其他变量的地址，可以修改和重新赋值

2.内存分配方式的不同
数组是在编译时分配的，内存是静态分配的
指针是在运行时分配的，内存是动态分配的

3.使用特性相似

数组作为函数参数传递时会退化为指向首元素地址的指针		但并不意味着数组名就是指针
数组和指针一样，使用下标法和指针算术

4.类型和大小不同
数组名的类型是数组，sizeof(数组名)返回的是整个数组的空间大小
指针的类型是指针，sizeof(指针)返回的是指针本身的大小，是地址长度的大小(不同字长的系统其指针大小不一样,)
		


*/
int main() {							
	int a = 5;
	char arry[5] = {};
	printf("%c",arry[1]);
	char arry2[4] = { 'a','b','c','\0'};	//字符串形式输出，则要手动补0
	printf("%s",arry2);
	int arry3[10] = { 1 };
	int test1[2] = { 3,4 };
	putchar('\n');
	printf("%p %p",test1,(test1+1));		                //%p,地址的输出格式 			指针算术
	putchar('\n');							//注意:*(test1)+1不是指针算术，这是对指针解引用后的值再算术运算，不是直接对指针进行算术运算
	printf("%d %d", *test1, *(test1 + 1));	//注意单目操作符的优先级，尽量使用()优先级操作符避免出错		指针算术
	return 0;

}
