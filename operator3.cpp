#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

/*

<数据以二进制补码的形式在计算机中存储,运算,处理>!!!

涉及到二进制的原反补
有符号机器数(即二进制数)						暂不讨论无符号机器数
正数的原反补一致
负数原反补...

注意:0的补码是唯一的(就是0),即0在计算机中存储的方式也是唯一的
―>无论是+0(原码码:000...0)还是-0(原码1000...000)通过补码规则转换后最后都为0000...00
―>10000...000(-0)取反+1后最高位溢出就被丢弃了,所以结果也为0000...0000

注意2：对于符号位,除了原反补的转换不参与计算,其他的所有运算都作为二进制参与运算

补码:将减法转换为加法(+负数)方便计算机运算――>所以解释了为什么只有负数的原反补才有区别

所以正数以补码存储在计算机中和原码没有区别
而负数以补码的形式存储在计算机中则有区别
注意在做相关计算时,以补码的形式做完计算后要根据符号位反转为原码才是理论正确结果

1)
移位操作符	不会改变操作的对象,只会获取一个运算后值,例如表达式a+5	注意:移位操作符操作的是整数
a<<x
将a的2进制向左移动x位，高位丢弃,低位补零
a>>x
将a的2进制向右移动x位
1.算术右移	低位丢弃,补原符号
2.逻辑右移	低位丢弃,补0
具体是什么类型的右移取决于编译器	可以自己测试

/////////////////////////////////////////////////////
例如-1:原码	10000000 00000000 00000000 00000001
	   反码 11111111 11111111 11111111 11111110
	   补码 11111111 11111111 11111111 11111111
   算术运算 11111111 11111111 11111111 11111111
	   原码	10000000 00000000 00000000 00000001	=-1
   逻辑运算	01111111 11111111 11111111 11111111
	   原码	00000000 00000000 00000000 00000001	=1
/////////////////////////////////////////////////////

2)
按位操作符	操作两个<整数>对应的二进制
& 按位与运算				全一为1,其余为0
| 按位或运算				有一为1,其余为0
~ 按位异或运算				以不同为主:不同为1相同为0

 
*/

int main() {
	int a = 1, b =0,c=0,d=-1;
	c = a << 1;
	b = d >> 1;
	printf("c=%d\n",c);
	printf("c=%d\n",b);		           //从测试得知vs2022使用的是算术右移
	int x = 3, y = 5, z = 0;
	int test1 = x & 5;
	int test2 = 3 | 5;
	int test3 = 3 ^ 5;
	int test4 = 3 & -5;
	/*
	3:00000000000000000000000000000011
 补码:00000000000000000000000000000011
   -5:10000000000000000000000000000101
 补码:11111111111111111111111111111011
	&:	
	  00000000000000000000000000000011
	  11111111111111111111111111111011
 补码:00000000000000000000000000000011
 原码:00000000000000000000000000000011=3

	*/
	printf("%d,%d,%d,%d\n",test1,test2,test3,test4);


	//按位操作符的妙用

	//交换两个整数不使用第三方变量
	int aa = 3, bb = 4;
	printf("交换前:a=%d,b=%d\n", aa, bb);
	//方法1					局限性:运算后的数字太大或者太小会造成溢出问题(正溢出，负溢出)
	aa = aa + bb;
	bb = aa - bb;
	aa = aa - bb;
	printf("交换后:a=%d,b=%d\n",aa,bb);

	printf("交换前:a=%d,b=%d\n", aa, bb);
	//方法2					  涉及到数逻相关知识
							//按位操作符:通过异或的互补规律	 可以用数字逻辑中的摩根定律推出来
							//俩原数异或得出的结果,与其中一个原数再异或可以反求出另外一个原数
							//推导过程:a^a=0,0^a=a;->得出结论,任意数和自己异或得0,0和任意数异或得出那个任意数
							// 所以(a^a)^a=a(a^a)=a							   ->得出结论：异或运算满足结合律
							//所以:a^b=a^b,(a^b)^b=a^(b^b)=a;	
							//与补码的补码就是原码,道理一致


	aa = aa ^ bb;			//111=011^100	不同为1相同为0得出结果,再异或↓
	bb = aa ^ bb;			//011=111^100	相同为0不同为1进行反推	
	aa = aa ^ bb;			//100=111^011
	printf("交换后:a=%d,b=%d\n", aa, bb);
	//按位变换操作不会出现进位，则也不会出现溢出的情况

	//练习	求一个整数存储在内存中的二进制1的个数
	//提示：和1进行按位与,一次判断一位(最低位),得出结果为1就计数(相同为1得出1),然后右移判断下一位(最低位+1)
	int f = 13,count=0,f1;
	f1 = f;
	while (f1) {
		if (f1 & 1)
			count++;
		f1 = f1 >> 1;
	}
	printf("%d的二进制有%d个1",f,count);
	return 0;
}