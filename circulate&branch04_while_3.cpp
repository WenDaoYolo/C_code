#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
int main() {
		int g;
	while ((g = getchar())!= EOF)
		putchar(g);
	    /*
	    实例:getchar的多次循环调用--->了解getchar读取缓冲区的原理--->初识<大致>了解,后续深入研究
		 拓展1：<回车也是字符(转义字符\n换行)，也会被getchar读取>
		 拓展2：输入端与getchar之间有一个缓冲区，输入端数据存入缓冲区，getchar从缓冲区获取数据
		
		程序第一次getchar
		getchar进入缓冲区获取数据,此时缓冲区没有任何数据,则getchar会等待缓冲区数据的输入
		输入端输入:A回车(\n),A\n存入缓冲区		--实质上是输入了两个字符
		getchar获取缓冲区第一个字符A赋值给g，并将该字符从缓冲区清除
		输出g(A)
		进行下一次循环
		判断到缓冲区还有数据
		getchar进入缓冲区获取第一个字符\n赋值给g,并将该字符从缓冲区清除
		输出g(\n)...
		进入下一次循环
		判断当前缓冲区：		所以第一次getchar缓冲区没有任何数据，因此不需要任何判断
		若还有数据时，继续读取字符并清除...依次类推直到缓冲区没有数据
		当判断到缓冲区没有数据时，等待输入端输入数据,然后输入端输入数据
		继续读取数据并循环...
		直到读取到EOF结束循环

		所以:1.getchar获取单个字符并非指一次只能输入一个字符，而是指getchar一次只能从缓冲区获取一个字符并返回
			 2.只要缓冲区有数据,即使输入端没有输入，getchar依然能读取数据(先缓冲区读取，再输入端输入)
		

		///////////////////////////////////////////////////////////////////////////////////////////////////
		？？？？？？？？？？？？？？？？？？？？？？？？？？？

		衍生问题:既然这样那该如何结束输入端的输入?
		涉及到相关知概念:文件，文件结束符,输入端...

		拓展3:文件结束符EOF(End Of File,实质上是系统定义的一个标识符常量值为-1)	#define EOF -1
		当文件读取数据错误或者结束时会以EOF结束
		EOF是getchar输入端的结束标志
		即getchar读取到EOF(键盘上ctrl+z，有的编译器为ctrl+d)则结束输入--注意输入方式:输入数据回车后,再ctrl+z回车
		
		??????????????????????????????????????????????????????
	*/

	return 0;
}

